#!/usr/bin/env bash
# TODO 
# echo RenÃ©e | iconv -f UTF-8 -t ASCII//TRANSLIT
# Recursively remove all special characters from filenames by renaming them to their ASCII normalized forms.
#
# By default it does a dry run, to actually move the files uncomment the `mv -vi ...` line.
#
# This is useful for cleaning up network shares that will be shared via SMB/NFS between Unix/macOS/Windows
# where non-ASCII filenames can sometimes cause "file does not exist" errors when trying to access the files.
#
# This script removes leading/trailing whitespace in filenames and replaces accents and non-english 
# characters with their ASCII equivalent, if no ASCII equivalent exists, it removes the character e.g.:
#    some_name_iÌ.txt -> some_name_i.txt
#    some_name_Ã¡.txt -> some_name_a.txt
#    some_name_Ã©.txt -> some_name_e.txt
#    some_name_^.txt -> some_name_.txt
#    some_name_ðŸž.txt -> some_name_.txt
#    some_name_Ð².txt -> some_name_.txt

IFS=$'\n'

folder="."
allowed_characters="a-zA-Z0-9_\. \/@#\~&$+()\'!-"
normalize_cmd="
import re
import unicodedata

normalized = unicodedata.normalize('NFD', input()).encode('ascii', 'ignore').decode('utf-8')
stripped = re.sub('[^$allowed_characters]', '', normalized)
print(stripped)"

badfiles=$(find "$folder" -name '*' | grep ".*[^$allowed_characters].*" | awk '{ print -length, $0 }' | sort -n -s | cut -d" " -f2-)

for path in $badfiles; do
    oldpath="$path"
    newpath=$(echo "$oldpath" | python3 -c "$normalize_cmd")
    echo "From: $oldpath"
    echo "To:   $newpath"
    # mv -vi -- "$oldpath" "$newpath"
    echo "--------------------------------------------"
done
