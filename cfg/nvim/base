global kind, word, spairs, is

-- index symbols
kind = {}

-- error handling
err = (msg, lvl = 2) -> error msg, lvl

-- word containers
word =
	<call>: (name) =>
		err "Word recursion #{@name} -> #{name}" if is.wrd @
		err 'Non string word name' unless is.str name
		<>: word.<>, [kind]: 'wrd', :name, value: true
	<unm>: => 
		@value = false
		@
	<add>: (value) => 
		err 'Can only add words' unless is.wrd value
		@value = { @name } if not is.tbl @value
		@value[] = value.name
		@
	<div>: (value) =>
		value = value.name if is.wrd value
		@value = value
		@
	<tostring>: => switch type(@value)
		when 'boolean', 'table' then @name
		else tostring(@value)
--[[ toggle
call next
cycle default v f
store cycle indexes
restore save
]]
-- bare strings as words
_G.<index> = (name) => if bare then word name


kpair = (kt) -> (t, k) ->
	k, v = next(t, k)
	k, v = next(t, k) while v? and not kt k
	k, v

-- iterators for specific key types
spairs = (t) -> kpair(is.str), t
wpairs = (t) -> kpair(is.wrd), t

-- type guard helpers
primitive =
	num: 'number', bol: 'boolean', str: 'string',
	fun: 'function', tbl: 'table', udt: 'userdata'
is =
	<call>: (x, q, t = type(x), p = primitive[q]) =>
		t == p or (t == 'table' and q == x[kind])
	<index>: (q) => (x) -> @ x, q
